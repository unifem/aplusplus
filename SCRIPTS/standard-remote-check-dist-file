#!/bin/sh

# This script executes the standard remote checks on an A++P++ distribution
# file.  It uses remote-check-dist-file to launch remote tests.  That script
# in turn uses check-dist-file to execute the distribution check on the
# remote machine.

# The standard checks are defined in the variable test_indices below.

# Instructions: Run with no arguments to get help message.

# Written by Brian Gunney.

# For each check it saves the log file in $top_results_dir

# Make sure PWD is correctly defined.  It may not be under sh.
PWD=`pwd`; export PWD

# The name of this script.
script_name=`basename $0`
export script_name
# We want dir_name to be absolute.
dir_name=`dirname $0`
case "$dir_name" in
  /*) : ;;
  *) dir_name="$PWD/$dir_name" ;;
esac

# Check arguments.
if [ $# -lt 1 ]; then
  cat <<EOF
Usage: $script_name <distribution file> [top results directory]
  [top results directory] is the top level directory for data
  generated by this script.

This script looks for four other scripts in the same directory
where it resides:  check-dist-file, remote-check-dist-file,
rcdf-config and sla.sh.  If you copy this script to another location,
please be sure to copy the other two also.
EOF
  exit 1
fi

# Name of distribution file.
dist_file=$1
shift
dist_file=`echo $dist_file | sed "s:^[^/]:$PWD/&:"`

# Top directory for all runs using this script.
# Defaults to current directory if not specified.
if [ "$1" ]; then
  top_results_dir=$1
  shift
else
  top_results_dir=$PWD
fi
top_results_dir=`echo $top_results_dir | sed "s:^[^/]:$PWD/&:"`

# This script uses LOGNAME and HOSTNAME.
# Sometimes (such as under cron), HOSTNAME is not defined.
# Make sure they are defined.
if test ! "${LOGNAME+set}" = set; then LOGNAME=`whoami`; fi
if test ! "${HOSTNAME+set}" = set; then HOSTNAME=`hostname`; fi
export LOGNAME HOSTNAME

# Make a (space-separated) list of people to report failures to.
failure_custodians="$LOGNAME@$HOSTNAME"

# Create a time stamp string to help identify this particular run.
time_stamp=`date +%Y%m%d_%H%M%S`

# Define the die function similar to Perl.
# Make it gaudy.
die () {
    echo "ERROR_MESSAGE_FROM $script_name:"
    if [ "$2" ]; then echo "Error: $2"; fi
    if [ "$1" ]; then exit $1; fi
    exit 99
}

# The scripts and supplementary files used for testing.
# Note that we are assuming that these files reside in
# the same directory as this script.
cdf=$dir_name/check-dist-file
rcdf=$dir_name/remote-check-dist-file
slash=$dir_name/sla.sh
rcdfrc=$dir_name/rcdf-config
for i in $cdf $rcdf $slash $rcdfrc; do
  test -r "$i" || die 1 "file $i is missing (should be in same directory as $script_name)."
done

# These are the standard tests we run for A++P++.
# If run from within LLNL, they should not require passwords.
test_indices="$test_indices lx"
test_indices="$test_indices sun"
test_indices="$test_indices sun_gnu"
test_indices="$test_indices tera"
test_indices="$test_indices tera_nopadre"
test_indices="$test_indices tera_kcc"
test_indices="$test_indices riptide"
# test_indices="$test_indices blue_nopadre_mpcc"


# Change directory if necessary.
if [ "$top_results_dir" != "$PWD" ]; then
  mkdir -p $top_results_dir || die 1 "Cannot create $top_results_dir"
  cd $top_results_dir || die 1 "Cannot cd to $top_results_dir"
fi

# Write out header so people know what the heck the output is about.
cat <<EOF

This is the A++P++ automated check program "$0".
It takes a distribution file and launches all standard
A++P++ checks on remote accounts via the script
$rcdf.
It is being run by "$LOGNAME@$HOSTNAME" with process id $$ from the
directory "$PWD".
Log files are placed in directory $top_results_dir.
The time stamp for this run is $time_stamp.

The standard test cases are: $test_indices

EOF


# Show environment.
echo "Here is the environment:"
set
echo


# Launch the standard tests, redirecting output into individual log files.
for i in $test_indices; do
    com="$rcdf --rcfile=$rcdfrc $cdf $slash $dist_file --test_index=$i"
    echo
    echo "Starting: $com"
    $com > $i.remote-check-output 2>&1 &
    eval "pid_${i}=$!"
    echo "PID for $i is $!.  Log file is $i.remote-check-output"
done


# Wait for processes to complete.
cat <<EOF

Waiting for background processes to complete.
Remember we are waiting for the
$rcdf script to complete.
Whatever processes are launched by $rcdf,
this script has no control over.  That is why
it is important to read the output of the
$rcdf script
to see whether the scripts it launched finished properly, etc.

EOF
echo "Waiting starting at `date`."

rcdfb=`basename $rcdf`
live_cases=`echo $test_indices | sed -e 's/^ \{1,\}//g' -e 's/ \{1,\}$//g'`
# echo "live_cases is <$live_cases>"
fail_count=0	# Number of processes failed.
pass_count=0	# Number of processes passed.
hung_count=0	# Number of processes hung.
start_wait=`perl -e 'print time'`	# Time we start waiting.
# echo "start_wait is <$start_wait>"
max_wait=21600	# Maximum time, in seconds, to wait for all processes.
stop_wait=`expr $start_wait + $max_wait`
# echo "stop_wait is <$stop_wait>"
while [ -n "$live_cases" ]; do
    # echo "live_cases is <$live_cases>"
    # echo waiting
    sleep 60	# It will take long.  No hurry.  Let the cpu do other things.
    for i in $live_cases; do	# Check the proceses still alive at last check.
	eval "pid=\$pid_${i}"
	# echo checking $pid for $i
	#ps -p $pid > /dev/null
	psout=`ps -p $pid | sed -n /$pid/p | sed -e '/defunct/d' -e '/zombie/d'`
	if [ -z "$psout" ]; then
	    # This process is no longer running.
	    echo
	    echo "Process $pid for case $i is finished by `date`"
	    eval "unset pid_${i}"	# Unset pid variable case $i.
	    grep "^$rcdfb PASSED" $i.remote-check-output
	    if [ $? -ne 0 ]; then
		echo "    Test case $i FAILED!"
		echo "    Check the log file $top_results_dir/$i.remote-check-output"
		fail_cases="$fail_cases $i"
		fail_count=`expr $fail_count + 1`
	    else
		pass_cases="$pass_cases $i"
		pass_count=`expr $pass_count + 1`
	    fi
	    # Remove case $i from the live_cases.
	    live_cases=`echo " $live_cases "	\
		| sed "s/ \{1,\}$i \{1,\}/ /"	\
		| sed -e 's/^ \{1,\}//g' -e 's/ \{1,\}$//g'`
	fi
    done
    time=`perl -e 'print time'`	# Current time.
    # echo "time is <$time>"
    if [ $time -ge $stop_wait ] && [ -n "$live_cases" ]; then
	# Processes is alive but time ran out.
	echo
	echo "It is now `date`"
	echo "$max_wait seconds has passed."
	echo "Any incomplete tests after this point is considered hung!"
	for i in $live_cases; do
	    echo
	    echo "    Test case $i ran out of time, possibly hung!"
	    echo "    Check the log file $top_results_dir/$i.remote-check-output"
	    hung_cases="$hung_cases $i"
	    hung_count=`expr $hung_count + 1`
	done
	break	# Exit while loop due to time running out.
    fi
done


# Define a function to write the summary_report.
# Do not inline this funcetion because may have
# to write the report more than once.
summary_report () {
    cat <<EOF

$fail_count failed and $hung_count hung checks were found in the standard tests by
    user: ${LOGNAME}@${HOSTNAME}
    process: $$
    time stamp: $time_stamp
    finished at: `date`
    run from: $top_results_dir
    program: $0

$pass_count passed cases: $pass_cases
$fail_count failed cases: $fail_cases
$hung_count hunged cases: $hung_cases

The log file for each case <case_name> is called
"case_name.remote-check-output".

If there are any failures, check the appropriate log files in
$top_results_dir on $HOSTNAME for further details.

If there were any failures, a failure report would be sent to $failure_custodians.
Log files for failed cases are attached in the emailed failure report (if any).

EOF
}


# Log final summary report.
summary_report

if [ -n "$fail_cases" ] || [ -n "$hung_cases" ]; then
    # Email notification of failed tests.
    if [ -n "$failure_custodians" ]; then
	# Form the attachment list.
	for i in $fail_cases $hung_cases; do
	    echo "Attaching log file $i"
	    attachments="$attachments -a $i.remote-check-output"
	done
	echo "attachments are $attachments"
	summary_report | mutt -F /dev/null	\
	    -s "$script_name found errors in A++P++ run by ${LOGNAME}@${HOSTNAME}"	\
	    $attachments $failure_custodians
	if [ $? -ne 0 ]; then die 1 "running mutt to send error report"; fi
	echo "Because not all tests passed, a summary report was mailed to: $failure_custodians"
    fi
    exit 1
fi

exit


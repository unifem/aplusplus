#!/usr/bin/expect --

# Written by Brian Gunney
# Please see Brian (gunney1@llnl.gov) if you have questions or comments
# regarding this script.

# General comments.
#
# This script is meant to stage, launch, log and monitor a remote process.
# After the completion of the remote process, it obtains the result,
# retrieves the log from the remote process and perform some degree of
# cleaning up after itself.
#
# Use the --help feature for a summary of what this script does.
#
# The ssh and scp command wrappers issue those commands using send instead
# of spawn.  This is required to make the wrappers general.  They may be
# used in any shell, local or remote.  Spawned commands are only spawned
# on the local machine where this expect script is running.

# Known deficiencies and bugs:
#
# This script relies heavily on the the network and the ssh/scp
# authentication in that if it fails any ssh or scp command,
# it exits with an error.  To minimize vulnerability to these events,
# The script is designed so that it does not stay logged in remotely
# for extended periods of time.  However, should that failure occur
# when a remote session is in progress or being started, this script
# will exit with a failure.  Your recourse in that event is to
# manually check the remote log to determine the result of the remote
# process.

# To do list:
#
# Make this script more tolerant with respect to temporary network and
# authentication failures.
#
# Change enter_password to ask user if she really wants to save an individual
# password.  Not all passwords need to be saved.


# Left border markings for output, error and received diagnostic messages.
global obord ebord rbord vbord
set obord "SCR:"
set ebord "ERR:"
set rbord "RCV:"
set vbord "VRB:"



# Define a function for verbose output.
proc send_verbose { level string } {
    global verbose vbord
    if { $level <= $verbose } {
	send_user "$vbord $string"
    }
}



# Get the script name and the directory name.
regsub "^.*/" [info script] "" script_name
regsub "/?$script_name\$" [info script] "" dir_name
if { [string compare $dir_name "" ] == 0 } { set dir_name "." }



# Define the help function.
proc print_help_message {} {
    upvar script_name script_name
    send_user "Usage: $script_name options files"
    send_user {

  This script is for running a program (in practice, likely to be a
    script) on a remote computer account.

  What this script does:
    Copy test program (or script) and supporting files to test machine.
    Logon to test machine.
    Launch test
      Run the test program in the background.
      Save result to a log file.
      Exit the testing account with the test running.
    Periodically log into the test account to see if the test is finished.
    When the test is finished:
      Determine result of the remote test (passed or failed).
      Bring back the remote log file.

  options:
    --help
	Print this message and exit.
    --verbose[n]
	Set verbosity level.  (Optional argument n is 5 if omitted.)
	Range of verbosity is 0-10.  0 is minimal.  1 is the default.
    --rcfile=[...]
	Specify the configuration file for this script.
	Defaults to .rcdfrc in the current or home directory.
	The rcfile is a convenient way for specifying the command
	line arguments for this script.  All command-line options
	(except --help) are specifiable via the rcfile.  Syntax for
	the rcfile is the same as the command line syntax (i.e. of
	the form --option[=][...]).  Blank lines and lines starting
	with '#' are discarded.
    --account=[...]
	Define a test account.  The argument should be the index
	of the account, followed by at least 1 white character,
	followed by tcl syntax for an 8-element list defining the account
	parameters.  The index must be alphanumeric.  Test account
	definition can be rather long and is best placed in an rcfile.
	Repeating this options defines multiple test accounts.
	At least one account must be defined.
    --test_index=[...]
	Specify the index of the test account.  This is required if
	you define more than one test account.
    --pass_string=[...]
	Write given phrase as the last output line, if this script passes.
	Defaults to "<script_name> PASSED".
    --fail_string=[...]
	Write given phrase as the last output line, if this script fails.
	Defaults to "<script_name> FAILED".

  files:
    A list of files to copy to the remote testing account.
    The first file is required and should be test program.
    Other files may be a distribution file being tested, the
    supporting files, etc.

  bugs and deficiencies:
    See comments in this script.
}
}



# Get the sla functions for command-line and configuration file processing.
if { ![file readable "$dir_name/sla.tcl"] } {
    send_error "$ebord $dir_name/sla.tcl is not found or not readable.\n"
    send_error "$ebord $script_name uses sla to process arguments and configuration files.\n"
    send_error "$ebord You must put a copy of sla.tcl in $dir_name.\n"
    send_error "$ebord You can find sla at http://sla.sourceforge.net.\n"
    send_error "$ebord Just copy the sla.tcl file from version 1.9.3 to $dir_name.\n"
    send_error "$ebord Warning: the tcl version of sla is in development and highly unstable.\n"
    exit 1
}
source "$dir_name/sla.tcl"
# Set the assignment operator to match one of:
#   The simple = sign 
#   The colon separated by white characters in either
#      the shell (which splits the argument) or
#      the configuration file (which leaves the string alone).
set assop {=[ \t]*|:($|[ \t]+)}
set flind {--}



# Error checking for command line
set sla_com [sla_scan lcom argv $flind {[ \t]*$} {help}]
regsub {\{\}} $sla_com 1 sla_com
eval $sla_com
if { [info exists help] } {
    print_help_message
    exit 0
}



# State how this script is run.
send_user "This is $script_name, run as:\n"
send_user "[info script] $argv\n"



# Determine the name of the configuration file.
# First default is .rcdfrc in current directory.
# Second default is .rcdfrc in home directory.
# Default is overridden by --rcfile=...  flag.
set rcfile ".rcdfrc"
if { ![file readable "$rcfile"] } { set rcfile "$env(HOME)/.rcdfrc" }
# Allow user to override configuration file name.
# puts "rcfile is $rcfile"
set sla_com [sla_scan lcom argv $flind $assop rcfile]
eval $sla_com
# If user specified the rcfile, it must be found.
if { [string compare $sla_com ""] != 0 } {
    if { ![file readable "$rcfile"] } {
	send_error "$ebord the specified configuration file $rcfile is not found.\n"
	exit 1
    }
} else {
    if { ![file readable "$rcfile"] } {
	unset rcfile
    }
}

# Read in configuration file if it is defined at this point.
if { [info exists rcfile] } {
    set file [open $rcfile]
    # Read in the configuration file, discarding blank lines and comments.
    while { [gets $file line] != -1 } {
	if { ! [ regexp "^\[ \t]*(#|$)" $line ] } {
	    # The line is not to be discarded as a comment.
	    # Prepend the lines read to argv as they will be treated
	    # the same way as command-line arguments.
	    set argv [ linsert $argv 0 $line ]
	}
    }
}



# Verbose flag for this script.
# 0 for minimal verbosity.
# 1 for normal verbosity.
# >1 (up to 10) for debugging verbosity.
global verbose
set verbose 1
set sla_com [sla_scan lcom argv $flind "" "verbose"]
regsub {\{\}} $sla_com 5 sla_com
eval $sla_com
if { $verbose != 0 } {
    send_verbose 4 "verbosity set to $verbose\n"
}
send_verbose 4 "Equivalent arguments after processing verbose flag.\n"
foreach i $argv { send_verbose 4 "$i\n" }


# Do not print out indiscriminately everything that comes down the pipeline.
# Printing will be done explicitly with send_verbose commands.
log_user 0


# Define debugging function to output everything when we encounter
# an unexpected timeout.  This just shows what was there so we can
# determine why we did not expect it.
proc unexpected_timeout { string } {
    send_error "$ebord Unexpected timeout encountered.\n"
    send_error "$ebord $string"
    send_error "$ebord Here is what is in the buffer:\n"
    expect * { send_error "$ebord $expect_out(buffer)\n" }
    exit 1
}


# Set the strings to output to indicate passed or failed test.
set pass_string "$script_name PASSED"
set fail_string "$script_name FAILED"
eval [sla_scan lcom argv $flind $assop "pass_string|fail_string"]
send_verbose 10 "Pass string is '$pass_string'\n"
send_verbose 10 "Fail string is '$fail_string'\n"


send_verbose 3 "PATH is $env(PATH)\n"


# Some environment variables may be unset under cron runs.  Set them.
if { ! [info exists env(PWD)] } {
    set env(PWD) [pwd]
    send_verbose 4 "PWD is set to $env(PWD)\n"
}
# LOGNAME is not set when running under cron.
if { ! [info exists env(LOGNAME)] } {
    send_verbose 3 "Setting env(LOGNAME)\n"
    spawn whoami
    expect -re (.*)\r\n {} timeout { unexpected_timeout "after whoami\n" }
    send_verbose 4 "$expect_out(1,string)\n"
    set env(LOGNAME) $expect_out(1,string)
    expect eof; wait -nowait
}
send_verbose 3 "env(LOGNAME) is set to '$env(LOGNAME)'\n"
# HOSTNAME is not set when running under cron.
if { ! [info exists env(HOSTNAME)] } {
    send_verbose 3 "Setting env(HOSTNAME)\n"
    spawn hostname
    expect -re (.*)\r\n {} timeout { unexpected_timeout "after hostname\n" }
    send_verbose 7 "$expect_out(1,string)\n"
    set env(HOSTNAME) $expect_out(1,string)
    expect eof; wait -nowait
    send_verbose 3 "env(HOSTNAME) is '$env(HOSTNAME)'\n";
}




# Initial prompt patterns (ipp) we may encounter upon login.
# It is not necessary to have these set correctly, but
# it saves a bit of time.  If you do not know the right
# prompt pattern to use, leave it blank.  A check for
# successful login will be made if a timeout is encountered
# before the initial prompt is recognized.
# Definitions:
# ipp_sh: Bourne shell's default initial prompt.
# ipp_csh: C shell's default initial prompt.
# ipp_bash: Bash's default initial prompt.
# ipp_shell: Any of the above shell prompts.
set ipp_sh {\n\$\ }
set ipp_csh {\n%\ }
set ipp_bash {\nbash-.*-\$\ }
set ipp_shell "($ipp_sh|$ipp_csh|$ipp_bash)"



# Define the wait interval between checking on the remote processes.
set wait_interval 300
eval [sla_scan lcom argv $flind $assop {wait_interval}]
send_verbose 5 "Wait interval set to $wait_interval seconds.\n"



# Define account to be a list of strings for defining test accounts.
sla_scan lcom argv $flind $assop {@account}
foreach i $lcom {
    # puts "$i"
    eval "$i"
}
# Convert strings in account list to entries in test_accounts.
if { ![info exists account] } {
    send_error "$ebord You did not specify any account.\n";
    exit 1;
}
foreach i $account {
    # puts $i
    # Separate the account index from the account definition.
    regexp "\[ \t\]*(\[a-z0-9_\]*)\[ \t\]*(.*)" $i all acind acdef
    # puts "acind: $acind"
    # puts "acdef: $acdef"
    # puts "set test_accounts($acind) \"$acdef\""
    eval set test_accounts($acind) \"$acdef\"
    # eval puts \$test_accounts($acind)
}
unset account


# Write out the defined test accounts.
send_verbose 5 "$obord There are [array size test_accounts] test accounts defined:\n"
foreach i [ array names test_accounts ] {
    send_verbose 5 "$i: $test_accounts($i)\n"
}


# Select test account.
eval [sla_scan lcom argv $flind $assop test_index]
if { ![info exists test_index] } {
    if { [ llength [array names test_accounts] ] == 1 } {
	# There is only one account defined,
	# so let test_account select that one.
	set test_index [ lindex [array names test_accounts] 0 ]
	puts "$test_index"
	send_verbose 2 "Test account index has defaulted to the only account defined: $test_index.\n"
    } else {
	send_error "$ebord You did not specify the required test_index.\n";
	send_error "$ebord Use --test_index=...\n";
	exit 1
    }
}
if { ![info exists test_accounts($test_index)] } {
    send_error "$ebord The specified testing account '$test_index' is not defined.\n";
    send_error "$ebord Use --account='$test_index ...' to define it\n";
    exit 1
}
set test_account $test_accounts($test_index)
send_verbose 1 "Test account: $test_account\n"


# At this point, all options have been processed.
# argv should now be the list of files used in testing.
set files "$argv"
send_verbose 2 "Files are $files\n";
if { [llength $files] == 0 } {
    send_error "$ebord You did not specify any files.\n";
    send_error "$ebord You must specify at least the test program to run remotely.\n";
    exit 1
}
send_verbose 7 "Making sure all specified files can be found.\n"
foreach i $files {
    if { ![file readable "$i"] } {
	send_error "$ebord File $i does not exist or is not readable.\n"
	exit 1;
    } else {
	send_verbose 7 "File $i is found.\n"
    }
}


# Name, directory and base name of test script file.
# The test script file is always assumed to the the first
# file in the file list.
set test_script [lindex $files 0]
regsub "^.*/" $test_script "" test_script_base
regsub "^\[^/]" $test_script "$env(PWD)/\\0" test_script_path
send_verbose 3 "The test script file $test_script_base in $test_script_path\n"



# Prompt patterns we will be using.
set rp "REMOTE:";	# Remote shell prompt.
set lp "LOCAL:";	# Local shell prompt.
global rp, lp;	# Make prompts available to function scopes.
# Make sure the the prompts is something that would never
# be output by any process run by this script.  If it does, the
# script will get confused.  Prompts should be regular expressions.



# Information on accounts we will be using:
#
# Account info list are the following:
# 0 host (it is a good idea to include the full host name so that LLNL
#   computers can authenticate without interactive password input.)
# 1 account user name (blank to not specify)
# 2 port number (such as 922 for the LLNL computers; blank if unspecified)
# 3 patience (seconds to wait for the initial prompt before
#   testing to see of we are in without a recognized prompt.
#   Also seconds to wait for that test.
# 4 initial prompt pattern (a regular expression)
# 5 top directory.  Relative paths are taken relative
#   to the account home directory.)
# 6 friendly domain (domain on which no interactive password is required.
#   If a remote site shares this domain, we try to set things up so that
#   a password is not needed.)
# 7 run options (command line arguments to the testing program)
# Define some shorthands for accessing accounts.
# This is done strictly for code robustness.
proc ac_host { ac } { return [lindex $ac 0] }
proc ac_user { ac } { return [lindex $ac 1] }
proc ac_port { ac } { return [lindex $ac 2] }
proc ac_patience { ac } { return [lindex $ac 3] }
proc ac_ipp { ac } { return [lindex $ac 4] }
proc ac_top_dir { ac } { return [lindex $ac 5] }
proc ac_friendly_domain { ac } { return [lindex $ac 6] }
proc ac_test_args { ac } { return "[lindex $ac 7]" }



#############################################################################
# Define functions we will need later on.
# Functions starting with "spawn_" spawn processes.
# Functions starting with "sh_" are meant to execute in a shell environment,
# so set the spawn_id to that of a shell first.
# The major difference between a spawned process and a shell-launched process
# is that the spawned process always runs on the machine where expect is
# running, whereas the shell-launched process executes where the shell is
# running.  When using the shell-launched functions, make sure that spawn_id
# is set to the spawn id of the shell in which you want the function to send
# its commands.  Shell-interacting functions requires the prompt for that
# shell.
#############################################################################

# Define function to give a unique time stamp.
proc spawn_timestamp {} {
    spawn date +%Y%m%d_%H%M%S;
    expect eof; wait -nowait
    regsub "\[\r\n\]*$" $expect_out(buffer) "" ts
    return $ts
}

# Define function to exec a Bourne shell from another shell.
# We exec a Bourne shell because we do not want to write
# commands for all possible login shells. Once we exec the
# Bourne shell in a login session, we know that any Bourne
# shell syntax should be valid in that session.
proc sh_exec_sh { } {
    global obord rbord ebord debug
    send_verbose 2 "Resetting shell to sh.\n"
    set timeout -1;	# All process should return properly.
    # Now, we think we are at the log-in shell.
    send "exec sh\r"
    while { 1 } {
	expect {
	    -re "(\\$ ).*" {
		send_verbose 2 "Received sh prompt: $expect_out(1,string)\n";
		break
	    }
	    -re ".+" {
		send_verbose 2 "Ignoring while waiting for sh prompt:\n$expect_out(buffer)\n"
	    }
	}
    }
}

# Define function to set the prompt inside a Bourne shell.
proc sh_set_prompt { prompt } {
    global obord rbord ebord debug
    send "PS1='$prompt'\r";
    expect -re "$prompt.*$prompt";	# Swallow one prompt from the echoing
					# and one from the actual prompt.
    # In the future, we may want to set the PS2 prompt also,
    # in case we decide to have interactive compound statements.
    send_verbose 4 "Prompt has been set to $prompt\n"
}

# Define function to return the full internet address of
# a current host, defaulting to the current host.
proc sh_host_inet_address { prompt } {
    # I cannot find a portable way to get the full internet address.
    # "hostname" will not give full address.
    # Some machines do not support "hostname -f".
    # "domainname" works only on NIS-configured machines.
    # "nslookup" does not work if the host name is an alias.
    # So Perl comes to the rescue.
    send "perl -e '\$_=`hostname`;chop;\$_=(gethostbyname(\$_))\[0]; print \"\$_\\n\";'\r"
    expect -re "(\r\n)(\[^\r\n\]*)\r\n$prompt"
    # The above send and expect strings are EXTREMELY syntax sensitive!
    set address $expect_out(2,string)
    return $address
}

# Define function to transfer password.
# Password is passed in one of three ways.
# Direct: The user gives it directly to the current process.
# Stored: The user gives this script the password, which it remembers
#   and passes on to the current process.
# Recalled: The script recalls a previously remembered password
#   and passes it on to the current process.
# Needless to say the most secure way is the direct way.
# Due to the stty calls, the password remembering features
# only work in interactive mode.
global pws rempw_flag
set rempw_flag 1
proc enter_password { user_host_string } {
    upvar spawn_id spawn_id;	# Use current process of the calling proceedure.
    global pws rempw_flag obord rbord ebord vbord
    if { ! $rempw_flag } {
	# No password rememberance.  Issue password directly.
	send_user "$obord Enter password (direct) for $user_host_string:";
	interact "\r" return;	# Allow user to enter password
				# until he hits return.
	send_user "\n";	# Since we grabbed his return,
			# issue one to make his line jump.
	send "\r";	# Send a return to tell ssh that we have
			# completed typing the password.
    } else {
	if { [info exists pws($user_host_string)] } {
	    # Use the remembered password.
	    send "$pws($user_host_string)\r"
	} else {
	    # Ask the user for the password and remember it.
	    # I would like to implement a feature to ask the user
	    # if he wants this particular password remembered.
	    # Not all passwords need to be remembered!
	    send_user "$obord Enter password (remembered) for $user_host_string:";
	    stty -raw -echo
	    expect_user -re "(.*)\n"
	    send_user "\n"
	    stty raw echo
	    # Issue the password to the process requesting it.
	    send "$expect_out(1,string)\r"
	    # Remember the password.
	    set pws($user_host_string) $expect_out(1,string)
	    # Clear expect_out in case it gets accidently written out later.
	    set expect_out(buffer) ""
	    set expect_out(0,string) ""
	    set expect_out(1,string) ""
	}
    }
}

# Define function to spawn an ssh session.
# It returns the spawn_id of the session.
# The arguments prompt and command are optional.
# Set them to "" if not needed.  This function
# optionally issues a command to ssh, given in
# the variable command.  Because a command may not
# give the same prompting output as a regular login,
# the optional prompt variable may be given.
proc spawn_ssh { account prompt command } {
    global ssh obord rbord ebord debug
    # Launch an ssh process and return the spawned id.
    # The ssh call differs according to the account information.
    send_verbose 2 "spawn_ssh for $account <$prompt> <$command>\n"
    set ssh_options ""
    if { [string compare [ac_user $account] ""] != 0 } {
	# With user name.
	set ssh_options "$ssh_options -l [ac_user $account]"
    }
    if { [string compare [ac_port $account] ""] != 0 } {
	# With port.
	set ssh_options "$ssh_options -p [ac_port $account]"
    }
    send_verbose 2 "spawning ssh $ssh_options [ac_host $account]\n"
    eval spawn ssh $ssh_options [ac_host $account] $command
    send_verbose 2 "spawn id for ssh is $spawn_id\n"
    set timeout [ac_patience $account]
    # We will use the prompt variable, but set it to the account
    # initial prompt if the user did not explicitly give prompt.
    if { ! [string compare $prompt ""] } { set prompt [ac_ipp $account] }
    set num_timeouts 0;	# Count the number of timeouts during authentication
    			# to know when to give up.
    set echo_string_test "XyZpDq";	# This should be a pattern you do not
    					# expect.
    set all_outputs {};	# For debugging, catch all outputs in this variable.
    while { 1 } {	# Keep going over hurdles in the authentication
			# process until authenticated or failed.
	expect {
	    "*ommand not found*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Command not found\n";
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    -re ".*(denied|refused).*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Failed authentication\n";
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    "Bad host name*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Bad host name!\n";
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    "Host key not found*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Host key not found!\n$ebord To create the required host key, log in interactively.\n"
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    "password:" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		# Get the password.
		enter_password "[ac_user $account]@[ac_host $account]";
	    }
	    "Time out occured*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Time out occured on server end (exiting ...)\n"
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    -re ($prompt).* {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_verbose 2 "Got initial prompt '$expect_out(0,string)'\n"
		break
	    }
	    -re ".*$echo_string_test\r\n" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		if { $num_timeouts > 0 } {
		    # The first timeout used the echo string test
		    # and now we just found the string so we must be in.
		    send_verbose 3 "Received from string test: <$expect_out(0,string)>\n";
		    send_verbose 3 "All outputs:\n$all_outputs\n";
		    send_verbose 2 "You're in with an unrecognized prompt\n"
		    break
		}
	    }
	    -re ".+" {
		# Catch and save everything else for debugging purposes.
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_verbose 8 "Found unexpected output:\n";
		send_verbose 8 "All outputs:\n$all_outputs\n";
	    }
	    timeout {
		set num_timeouts [expr $num_timeouts + 1]
		send_verbose 3 "Num_timeouts increased to $num_timeouts\n"
		send_verbose 5 "All outputs so far this authentication:\n$all_outputs\n";
		if { $num_timeouts == 1 } {
		    # This is the first timeout.
		    # See if we may have an unrecognized prompt.
		    send_verbose 2 "Timed out.  You may have an unrecognized prompt.\n";
		    send_verbose 2 "Testing simple echo command...\n";
		    send "echo '$echo_string_test'\r"
		} else {
		    # This is the second timeout.  We are probably not in.
		    send_error "$ebord Timed out (number $num_timeouts) authenticating ssh connection\n"
		    exit 1;
		}
	    }
	}
    }
    # The only way to exit the above loop is to be properly authenticated,
    # so we must be in.
    return $spawn_id
}



# Function to perform an inbound secure shell copy.
# This will interact with the shell environment, so the prompt must be given.
# The spawn id should be set properly.  This function does not
# spawn anything.  The items may be multiple items, but if they
# are, destination must be a directory, as per normal ssh rules.
proc sh_scp_inbound { account prompt items destination } {
    upvar spawn_id spawn_id;	# Use current process of calling proceedure.
    global obord rbord ebord debug
    set inet_address [sh_host_inet_address $prompt]
    send_verbose 2 "inet_address is <$inet_address>\n"
    # Do not use the port flag if the port is not given in the account info.
    # Also, if the local and remote hosts are on the same domain, do not use
    # the port flag--this is so that the LLNL hosts will authenticate without
    # password.
    if { ( [string compare [ac_port $account] ""] == 0 )
	 || ( [string compare [ac_friendly_domain $account] ""]
	      && [string match "*.[ac_friendly_domain $account]" $inet_address] ) } {
	# Either the port was not specified or we are in the llnl.gov domain.
	# Do not specify the port.
	send_verbose 2 "scp -p [ac_user $account]@[ac_host $account]:'$items' $destination\n"
	send "scp -p [ac_user $account]@[ac_host $account]:'$items' $destination\r"
    } else {
	# Use the port specified in the account.
	set port_flag "-P[ac_port $account]"
	send_verbose 2 "scp -p $port_flag [ac_user $account]@[ac_host $account]:'$items' $destination\n"
	send "scp -p $port_flag [ac_user $account]@[ac_host $account]:'$items' $destination\r"
    }
    set timeout 3600;
    sh_scp_response $account $prompt;	# Respond to the scp dialog.
    # The only way to exit the above loop is to be properly authenticated,
    # so we must be in.
    return
}



# Function to perform an outbound secure shell copy.
# This will interact with the shell environment, so the prompt must be given.
# The spawn id should be set properly.  This function does not
# spawn anything.  The items may be multiple items, but if they
# are, destination must be a directory, as per normal ssh rules.
proc sh_scp_outbound { account prompt items destination } {
    upvar spawn_id spawn_id;	# Use current process of calling proceedure.
    global obord rbord ebord debug
    set inet_address [sh_host_inet_address $prompt]
    send_verbose 2 "inet_address is <$inet_address>\n"
    # Do not use the port flag if the port is not given in the account info.
    # Also, if the local and remote hosts are on the same domain, do not use
    # the port flag--this is so that the LLNL hosts will authenticate without
    # password.
    if { ( [string compare [ac_port $account] ""] == 0 )
	 || ( [string compare [ac_friendly_domain $account] ""]
	      && [string match "*.[ac_friendly_domain $account]" $inet_address] ) } {
	# Either the port was not specified or we are in the llnl.gov domain.
	# Do not specify the port.
	send_verbose 2 "scp -p $items [ac_user $account]@[ac_host $account]:'$destination'\n"
	send "scp -p $items [ac_user $account]@[ac_host $account]:'$destination'\r"
    } else {
	# Use the port specified in the account.
	set port_flag "-P[ac_port $account]"
	send_verbose 2 "scp -p $port_flag $items [ac_user $account]@[ac_host $account]:'$destination'\n"
	send "scp -p $port_flag $items [ac_user $account]@[ac_host $account]:'$destination'\r"
    }
    set timeout 3600;
    sh_scp_response $account $prompt;	# Respond to the scp dialog.
    # The only way to exit the above loop is to be properly authenticated,
    # so we must be in.
    return
}


proc sh_scp_response { account prompt } {
    # Respond to the scp dialog.
    # This function is used by the inbound and outbound scp wrappers.
    #
    # scp does not tell us if it is authenticating
    # or if it is actually transfering a file.
    # We set a long timeout in case the file being copied is large.
    # (The timeout given in the account info refers
    # to things like authentication.)
    # But we do not want to hang before the file
    # transfer starts, so it is important
    # to expect all possible outputs from the scp
    # command such as denied authentication, etc.
    upvar timeout timeout;	# Timeout value set by the calling proceedure.
    global obord rbord ebord debug
    set num_password 0;	# Number of times password is entered.
    set all_outputs {};	# For debugging, catch all outputs in this variable.
    while {1} {
	expect {
	    "*ommand not found*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Command not found\n";
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    -re ".*(denied|refused).*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Failed authentication\n";
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    "password:" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		# Get the password.
		enter_password "[ac_user $account]@[ac_host $account]";
		set num_password [expr $num_password + 1]
	    }
	    "Bad host name*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Bad host name!\n";
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    "Host key not found*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Host key not found!\n$ebord To create the required host key, log in interactively.\n"
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    "Time out occured*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Time out occured on server end (exiting ...)\n"
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    -re {[nN]o such*} {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Error: no such file or directory\n"
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    "not a regular file*" {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_error "$ebord Error: not a regular file\n"
		send_error "$ebord Error message:\n$expect_out(buffer)\n";
		exit 1
	    }
	    -re $prompt {
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_verbose 2 "$expect_out(buffer)\n"
		send_verbose 2 "scp copy successful after entering password $num_password times.\n"
		break;
	    }
	    -re ".+" {
		# Catch and save everything else for debugging purposes.
		set all_outputs "$all_outputs$expect_out(buffer)";
		send_verbose 8 "Found unexpected output:\n";
		send_verbose 8 "All outputs:\n$all_outputs\n";
	    }
	    timeout {
		send_error "$ebord Timed out\n"
		send_verbose 5 "All outputs so far this authentication:\n$all_outputs\n";
		send_error "$ebord No response after waiting $timeout seconds.\n"
		send_error "$ebord If the file needs more time, change the timeout in this script.\n"
		send_error "$ebord Otherwise, the scp command was probably unsuccessful\n"
		exit 1
	    }
	}
    }
}


################################################################################
# Finished defining the supporting functions.  Let the work begin!
################################################################################


# Write out a header to describe what the output is about.
send_verbose 1 "This is the script [info script].\n"
send_verbose 1 "It will launch a remote run of [lindex $files 0]\n"
send_verbose 1 "on the platform indexed $test_index\n"
send_verbose 1 "It is being run by $env(LOGNAME)@$env(HOSTNAME) as process [pid].\n"


# Spawn a Bourne shell to run the local commands.
spawn sh
set localsh_sid $spawn_id
sh_set_prompt $lp



# Define a really unique string identifying this run,
# taken from the time stamp, local host name and local hose pid.
# These are used in specifying paths under the paths defined in the accounts.
set unique_string "[spawn_timestamp]-[sh_host_inet_address $lp]-[pid]"



# Logon to test machine.
set spawn_id $localsh_sid
send_verbose 1 "Calling spawn_ssh for $test_index\n"
set ssh_sid [spawn_ssh $test_account "" ""]
send_verbose 3 "Spawn id for ssh is $ssh_sid\n"
set spawn_id $ssh_sid
send_verbose 1 "Running on [ac_host $test_account]\n"
# Change shell and prompt
sh_exec_sh
sh_set_prompt $rp



# Define a really unique path for the testing directory.
# This sets the files for this run apart from files from
# other runs that are also using the same top directory.
set unique_testing_dir_path "[ac_top_dir $test_account]/$unique_string"



# Create, enter and clean up test directory on test account.
set timeout -1
send "mkdir -p $unique_testing_dir_path\r";	expect $rp; send_verbose 2 "$expect_out(buffer)\n";
send "cd $unique_testing_dir_path\r";
expect {
    "not found" {
	send_error "$ebord Error cd to $unique_testing_dir_path\n";
	exit 1;
    }
    $rp {
	send_verbose 2 "$expect_out(buffer)\n";
    }
    timeout { unexpected_timeout "after cd to $unique_testing_dir_path\n" }
}



# Copy files to the test account.
# (Temporarily reset spawn_id to the local shell
# because this is a local command.)
send_verbose 1 "Copying files to test account [ac_user $test_account]@[ac_host $test_account]\n"
set spawn_id $localsh_sid
set timeout -1;	# Temporarily unset timeout because files copied may take long.
sh_scp_outbound $test_account  $lp "$files" "$unique_testing_dir_path"
set spawn_id $ssh_sid
set timeout [ac_patience $test_account];	# Reset test account's timeout.



# Print out some useful confirmations.
send "pwd\r";	expect -re \[^\n\]*\n?(.*)\r\n$rp;	send_verbose 1 "Directory: $expect_out(1,string)\n"
send "ls -l\r";	expect -re \[^\n\]*\n?(.*)\r\n$rp;	send_verbose 1 "Contents:\n$expect_out(1,string)\n"
send "date\r";	expect -re \[^\n\]*\n?(.*)\r\n$rp;	send_verbose 1 "Time: $expect_out(1,string)\n"



# Define the file name of the log for this test.
set log_file_name "log.$unique_string"
set latest_log_file_name "$unique_testing_dir_path/$log_file_name"



# Run the distribution script in backgound mode.
# Put the log file in the parent directory because
# the current directory will be removed if the test passes.
set com "nohup nice ./$test_script_base [ac_test_args $test_account] > ../$log_file_name 2>&1"
send_verbose 1 "launching test: $com &\n"
send "$com &\r"
expect -re (.*)\r\n$rp {} timeout { unexpected_timeout "after launching remote test\n" };
send_verbose 1 "$expect_out(1,string)\n"



# Set test_script_pid to the process id of the test script running remotely.
send "echo \$!\r";	expect -re (\[0-9\]+).*\r\n$rp {} timeout { unexpected_timeout "trying to get remote pid\n" };
send_verbose 2 "$expect_out(1,string)\n"
set test_script_pid $expect_out(1,string)
send_verbose 1 "Test script pid is $test_script_pid\n";



# Set up some links for convenience
# (the real file names are long because they should be unique).
send "ln -s ../$log_file_name log\r";
expect -re \[^\n\]*\n?(.*)\r\n$rp {} timeout { unexpected_timeout "after first ln -s command\n" };
send_verbose 4 "Created link 'log' to log file $log_file_name\n";
send "rm -f ../latest-log\r";
expect -re \[^\n\]*\n?(.*)\r\n$rp {} timeout { unexpected_timeout "after rm -f ../latest-log\n" };
send_verbose 4 "Removed old latest-log link\n";
send "ln -s $log_file_name ../latest-log\r";
expect -re \[^\n\]*\n?(.*)\r\n$rp {} timeout { unexpected_timeout "after second ln -s command\n" };
send_verbose 4 "Created link 'latest-log' to $log_file_name\n";



# Exit the session where the test script is launched as a background process.
# I had a problem exiting the ssh session,
# perhaps caused by the above commands happening too fast.
# I found that sleeping a little here helps.  BTNG.
sleep 10;
send "exit\r";
expect * {} timeout { unexpected_timeout "leaving ssh\n" };
send_verbose 10 "Output from exit command was: $expect_out(buffer)\n";
wait -nowait;	# Leave remote login session to run the check.
send_verbose 1 "Logged off from session to launch check script.\n"



################################################################################
# At this point, the remote test script should be running.
################################################################################



# Periodically check the remote process until it exits.
while 1 {
    send_verbose 1 "Sleeping $wait_interval seconds while remote process runs on [ac_host $test_account]...\n"
    sleep $wait_interval
    send_verbose 1 "Woke up to check on remote process.\n"
    send_verbose 2 "Calling spawn_ssh for $test_index ([ac_host $test_index])\n"
    # Launch a login shell on the test machine.
    # Note: Instead of logging on and exec'ing a sh, we could have used
    # ssh to launch a remote "sh -i" process, but doing this (for some
    # strange reason) sometimes (randomly) reverses the order between
    # the stdout output and the following initial prompt.  Also, doing
    # this does not leave flexibility for using telnet, as telnet does
    # not support launching a remote process.
    set ssh_sid [spawn_ssh $test_account "" ""]
    send_verbose 5 "Spawn id for ssh is $ssh_sid\n"
    set spawn_id $ssh_sid
    sh_exec_sh
    sh_set_prompt $rp
    # Go to the top test directory.
    send "cd [ac_top_dir $test_account]\r";	expect $rp {} timeout { unexpected_timeout "after cd\n" }
    # Show some useful information.
    send "pwd\r";	expect -re \[^\n\]*\n(.*)\r\n$rp {} timeout { unexpected_timeout "after pwd\n" }
    send_verbose 1 "Current directory: $expect_out(1,string)\n";
    send "ls -l $log_file_name $unique_string\r";	expect -re \[^\n\]*\n(.*)\r\n$rp {} timeout { unexpected_timeout "after ls\n" }
    send_verbose 1 "Contents:\n$expect_out(1,string)\n";
    # Show the current time.
    spawn date;
    expect -re (.*)\n;
    set local_time $expect_out(1,string)
    expect eof; wait -nowait;
    send_verbose 1 "Local time: $local_time\n"
    # Reset the spawn id changed by spawning date.
    set spawn_id $ssh_sid;
    # Show the time on the remote test machine.
    send "date\r";	expect -re \r\n(.*)\r\n$rp {} timeout { unexpected_timeout "after date\n" }
    set remote_time $expect_out(1,string)
    send_verbose 1 "Remote time: $remote_time\n";
    # Check on remote process.
    send "ps -p $test_script_pid\r";	expect -re \[^\n\]*\n(.*)\r\n$rp {} timeout { unexpected_timeout "after ps\n" }
    set ps_out $expect_out(1,string)
    # Remove up to and including line with "PID", in the ps output.
    regsub ".*PID\[^\n]*\n" $ps_out "" ps_out;
    send_verbose 2 "ps result\n$ps_out\n"
    # Conditions under which to stop checking on the test.
    if { [ regexp "<defunct>" $ps_out ] } {
	# The remote run has become defunct.
	set condition "defunct"
    } elseif { ! [ regexp "^ *$test_script_pid " $ps_out ] } {
	# The remote run did not show up in the ps output.
	set condition "stopped"
    }
    if { [info exists condition] } {
	# It is time to leave the monitoring loop and gather the results.
	break
    };
    send_verbose 1 "Process $test_script_pid is still running on [ac_host $test_account]\n"
    # Show the log file.
    send "tail $log_file_name\r";
    expect -re \[^\n\]*\n(.*)$rp {} timeout { unexpected_timeout "after tail\n" }
    send_verbose 1 "Tail of log file:\n$expect_out(1,string)\n";
    # Got what we needed.  Exit the remote login session.
    send "exit\r";	expect "*closed.*\n"; expect eof; wait -nowait;
    send_verbose 2 "Left login session at [ac_host $test_account] (test index $test_index)\n"
}



# Wrap things up.
if { ! [string compare $condition "stopped"] } {
    send_verbose 1 "test script has stopped.  Leaving wait loop\n"
}
if { ! [string compare $condition "defunct"] } {
    send_verbose 1 "test script has become defunct.  Leaving wait loop\n"
}



# See if the run passed or failed by checking the log.
send "$unique_string/$test_script_base -check_output $log_file_name\r"
expect -re \[^\n\]*\n(.*)\r\n$rp {} timeout { unexpected_timeout "after checking pass-or-fail\n" }
set remote_test_status $expect_out(1,string)
send_verbose 3 "checking output log gives <$expect_out(buffer)>\n"
send_verbose 2 "remote test status is <$remote_test_status>\n"



# Show the entire log file.
send_verbose 0 "Begin log file:\n"
log_user 1;	# We expect a lot of output from the next command.
# On some platforms (at least Sun), the ssh session hangs in the middle
# of the long output from cat.  So we try to just output as much
# of the end of the log file as possible without hanging.
# send "cat $log_file_name\r";
# send "tail -c 10000 $log_file_name\r";
send "tail -50 $log_file_name\r";
expect -re \[^\n\]*\n(.*)$rp {} timeout { unexpected_timeout "after cat\n" }
log_user 0
send_verbose 0 "End log file:\n"



# Kill undead processes.
if { ! [string compare $condition "stopped"] } {
    send "kill -9 $test_script_pid\r";	expect $rp
}



# Report remote test status.
if { [string compare $remote_test_status "pass"] } {
    send_verbose 1 "Remote test failed\n"
    send_verbose 1 "Leaving behind all intermediate data.\n"
} else {
    send_verbose 1 "Remote test passed\n"
    send_verbose 1 "Removing all intermediate data (except for the log file $log_file_name).\n"
    # Remove all but the log file
    # (background process so we can leave immediately).
    send_verbose 1 "Issuing commands to remove all intermediate files (save log file)\n"
    send "nohup rm -rf $unique_string\r";	expect $rp
}



# Log off remote machine.
send "exit\r";	expect "*closed.*\n"; expect eof; wait -nowait;



# Bring back log file.
# (Use the local shell spawned earlier to issue commands.)
set spawn_id $localsh_sid
sh_scp_inbound $test_account $lp "[ac_top_dir $test_account]/$log_file_name" "$test_index.$log_file_name"
send_verbose 1 "Test result has been copied to $test_index.$log_file_name\n"



# Create a link to the latest log brought back.
send "rm -f ../$test_index.latest-log\r";
expect -re \[^\n\]*\n?(.*)\r\n$lp {} timeout { unexpected_timeout "after rm -f ../$test_index.latest-log\n" };
send_verbose 4 "Removed old local index-specific latest-log link\n";
send "ln -s $test_index.$log_file_name $test_index.latest-log\r";
expect -re \[^\n\]*\n?(.*)\r\n$lp {} timeout { unexpected_timeout "after second ln -s command\n" };
send_verbose 4 "Created link '$test_index.latest-log' to $log_file_name\n";



# Exit the local shell.
send "exit\r";
expect eof; wait -nowait;



# Issue diagnostic regarding passing or failing.
if { [string compare $remote_test_status "pass"] } {
    send_verbose 1 "$script_name FAILED because $test_script_base failed\n"
    send_verbose 1 "The run was made using [ac_user $test_account]@[ac_host $test_account]\n"
    send_verbose 1 "in directory $unique_testing_dir_path\n"
    send_verbose 1 "with log file [ac_top_dir $test_account]/log.$unique_string\n"
    send_user "$fail_string\n"
    exit 1
} else {
    send_user "$pass_string\n"
    exit 0
}


